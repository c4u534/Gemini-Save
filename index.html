<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Operation Offload: Intelligent Workspace</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Roboto+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #111827; color: #f3f4f6; }
        .chat-bubble-user { background-color: #1f2937; border: 1px solid #374151; }
        .chat-bubble-ai { background-color: #374151; border: 1px solid #4b5563; }
        .code-block { font-family: 'Roboto Mono', monospace; }
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #1f2937; }
        ::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 4px; }
        .neon-glow { box-shadow: 0 0 5px rgba(13, 182, 150, 0.4), 0 0 10px rgba(13, 182, 150, 0.3); }
        .text-neon-green { color: #39ff14; text-shadow: 0 0 5px #39ff14; }
        .animate-float { animation: float-in 0.5s ease-out forwards; }
        @keyframes float-in {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200">

    <div class="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        <header class="text-center mb-8">
            <h1 class="text-3xl md:text-4xl font-extrabold tracking-tight text-white">Operation Offload</h1>
            <p class="mt-2 max-w-2xl mx-auto text-lg text-gray-400">A quantum workspace with automated artifact offloading to your Neural Matrix (Google Drive).</p>
        </header>

        <div id="auth-section" class="bg-gray-800 shadow-xl rounded-lg p-6 mb-8 text-center">
            <h2 class="text-xl font-bold text-teal-400 mb-4">Authentication Status</h2>
            <p id="auth-status" class="text-yellow-400 mb-4">Initializing quantum sync...</p>
            <button id="authorize_button" disabled class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md disabled:bg-gray-500 disabled:cursor-not-allowed">Sign In with Google</button>
            <button id="signout_button" class="hidden bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-md">Sign Out</button>
            <div id="drive-status" class="mt-2 text-sm text-gray-400"></div>
        </div>

        <div class="bg-gray-800 shadow-xl rounded-lg p-6">
            <div id="archive-controls" class="hidden bg-gray-700 rounded-lg p-4 mb-4">
                <div class="flex flex-wrap items-center justify-between gap-4 mb-4">
                    <h3 class="text-lg font-semibold text-white">üì¶ Archive & Download</h3>
                    <div class="flex flex-wrap gap-2">
                        <button id="download-current-chat" class="bg-purple-600 hover:bg-purple-700 text-white text-sm py-2 px-3 rounded disabled:bg-gray-500" disabled>üíæ Current Chat</button>
                        <button id="download-all-drive-content" class="bg-indigo-600 hover:bg-indigo-700 text-white text-sm py-2 px-3 rounded disabled:bg-gray-500" disabled>üìÅ All Drive Files</button>
                        <button id="bulk-download-interactions" class="bg-green-600 hover:bg-green-700 text-white text-sm py-2 px-3 rounded disabled:bg-gray-500" disabled>üóÇÔ∏è Bulk Export</button>
                        <button id="generate-summary-report" class="bg-yellow-600 hover:bg-yellow-700 text-white text-sm py-2 px-3 rounded disabled:bg-gray-500" disabled>üìä Summary Report</button>
                    </div>
                </div>
                <div id="download-progress" class="hidden">
                    <div class="bg-gray-600 rounded-full h-2 mb-2">
                        <div id="progress-bar" class="bg-blue-500 h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
                    </div>
                    <p id="progress-text" class="text-sm text-gray-300">Preparing download...</p>
                </div>
                <div id="download-status" class="text-sm text-gray-400"></div>
            </div>

            <div id="chat-window" class="h-96 overflow-y-auto bg-gray-900 p-4 rounded-lg border border-gray-700 mb-4 space-y-4">
                 <div class="w-full flex justify-start">
                    <div class="p-4 rounded-xl max-w-[90%] chat-bubble-ai neon-glow">
                         <p>Welcome to Operation Offload. Please sync with the Google Matrix to begin artifact generation.</p>
                    </div>
                </div>
            </div>

            <div class="flex items-center">
                <textarea id="prompt-input" class="flex-grow bg-gray-700 border-gray-600 rounded-l-md shadow-sm py-2 px-4 text-gray-200 focus:outline-none focus:ring-teal-500 focus:border-teal-500 resize-none" placeholder="Awaiting quantum sync..." rows="1" disabled></textarea>
                <button id="send-button" class="bg-teal-600 hover:bg-teal-700 text-white font-bold py-2 px-4 rounded-r-md self-stretch disabled:bg-gray-500 disabled:cursor-not-allowed" disabled>‚ö°TRANSMIT</button>
            </div>
        </div>
    </div>

    <script async defer src="https://apis.google.com/js/api.js?onload=gapiLoaded"></script>
    <script async defer src="https://accounts.google.com/gsi/client?onload=gisLoaded"></script>

    <script>
        // --- CONFIGURATION ---
        const CLIENT_ID = '700648198913-6itdi4jv7mhdhpq3ncqavndst36imo76.apps.googleusercontent.com';
        const API_KEY = 'AIzaSyCZIUCIhmX9H8Qr7PZJbkVu5Ue7ZOs-H9U'; // IMPORTANT: This key needs Google Drive API enabled
        const GEMINI_API_KEY = 'AIzaSyCZIUCIhmX9H8Qr7PZJbkVu5Ue7ZOs-H9U'; // IMPORTANT: This key needs Gemini API enabled
        const SCOPES = 'https://www.googleapis.com/auth/drive.file';
        const GEMINI_ENDPOINT = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent';
        
        let DRIVE_FOLDER_ID = null;
        let conversationHistory = [];

        // --- UI ELEMENTS ---
        const authorizeButton = document.getElementById('authorize_button');
        const signoutButton = document.getElementById('signout_button');
        const authStatus = document.getElementById('auth-status');
        const driveStatus = document.getElementById('drive-status');
        const chatWindow = document.getElementById('chat-window');
        const promptInput = document.getElementById('prompt-input');
        const sendButton = document.getElementById('send-button');

        let gapiInited = false;
        let gisInited = false;
        let tokenClient;
        let isProcessing = false;

        // --- INITIALIZATION ---
        function gapiLoaded() {
            gapi.load('client', initializeGapiClient);
        }

        async function initializeGapiClient() {
            try {
                await gapi.client.init({
                    apiKey: API_KEY,
                    discoveryDocs: ["https://www.googleapis.com/discovery/v1/apis/drive/v3/rest"],
                });
                gapiInited = true;
                console.log("GAPI client initialized.");
                maybeEnableButtons();
            } catch (error) {
                console.error("Error initializing GAPI client:", error);
                authStatus.textContent = "Error: Could not initialize Google API client.";
                authStatus.classList.add('text-red-400');
            }
        }

        function gisLoaded() {
            try {
                tokenClient = google.accounts.oauth2.initTokenClient({
                    client_id: CLIENT_ID,
                    scope: SCOPES,
                    callback: '', // Will be defined dynamically in handleAuthClick
                });
                gisInited = true;
                console.log("GIS client initialized.");
                maybeEnableButtons();
            } catch (error) {
                console.error("Error initializing GIS client:", error);
                authStatus.textContent = "Error: Could not initialize Google Sign-In.";
                authStatus.classList.add('text-red-400');
            }
        }

        function maybeEnableButtons() {
            if (gapiInited && gisInited) {
                authorizeButton.disabled = false;
                authStatus.textContent = "Ready to authenticate with Google Drive";
                console.log("Authentication system ready.");
            }
        }

        // --- AUTH LOGIC ---
        authorizeButton.onclick = handleAuthClick;
        signoutButton.onclick = handleSignoutClick;

        function handleAuthClick() {
            tokenClient.callback = async (resp) => {
                if (resp.error !== undefined) {
                    console.error("Authentication error:", resp);
                    authStatus.textContent = `Auth Error: ${resp.error_description || resp.error}`;
                    authStatus.classList.add('text-red-400');
                    return;
                }
                await postAuthSetup();
            };

            if (gapi.client.getToken() === null) {
                tokenClient.requestAccessToken({ prompt: 'consent' });
            } else {
                tokenClient.requestAccessToken({ prompt: '' });
            }
        }

        async function postAuthSetup() {
            authStatus.textContent = 'Authorization successful! Setting up Drive folder...';
            authStatus.classList.remove('text-yellow-400', 'text-red-400');
            authStatus.classList.add('text-green-400');
            signoutButton.classList.remove('hidden');
            authorizeButton.classList.add('hidden');
            
            try {
                DRIVE_FOLDER_ID = await findOrCreateFolder('Gemini_Synapse_Offload');
                authStatus.textContent = `‚úÖ Quantum Sync Complete. Ready for transmission.`;
                driveStatus.textContent = `Neural Matrix: Gemini_Synapse_Offload`;
                
                // Enable chat functionality
                promptInput.disabled = false;
                sendButton.disabled = false;
                promptInput.placeholder = "Transmit your request to the quantum AI...";
                
                // Show and enable archive controls
                document.getElementById('archive-controls').classList.remove('hidden');
                enableArchiveFeatures();
                
            } catch (error) {
                authStatus.textContent = `Error setting up Drive folder: ${error.message}`;
                authStatus.classList.remove('text-green-400');
                authStatus.classList.add('text-red-400');
                console.error(error);
            }
        }

        function handleSignoutClick() {
            const token = gapi.client.getToken();
            if (token !== null) {
                google.accounts.oauth2.revoke(token.access_token);
                gapi.client.setToken('');
                authStatus.textContent = 'Signed Out. Please sign in to use the workspace.';
                authStatus.classList.remove('text-green-400');
                authStatus.classList.add('text-yellow-400');
                driveStatus.textContent = '';
                signoutButton.classList.add('hidden');
                authorizeButton.classList.remove('hidden');
                DRIVE_FOLDER_ID = null;
                
                // Disable chat functionality
                promptInput.disabled = true;
                sendButton.disabled = true;
                promptInput.placeholder = "Awaiting quantum sync...";
                
                // Hide archive controls
                document.getElementById('archive-controls').classList.add('hidden');
                disableArchiveFeatures();
            }
        }

        // --- ENHANCED CHAT & AI FUNCTIONS ---

        const extractionSettings = {
            filePrefix: 'op-offload_',
            preserveLinks: true,
        };

        const contentTypes = {
            code: { patterns: ['javascript', 'python', 'function', 'const', 'let', 'import', '<div>', 'class'] },
            list: { patterns: ['- ', '* ', '1.', '2.'] },
            document: { patterns: ['summary', 'report', 'analysis', 'overview'] }
        };

        async function callGeminiAPI(message) {
            try {
                const response = await fetch(`${GEMINI_ENDPOINT}?key=${GEMINI_API_KEY}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: message }] }],
                        generationConfig: {
                            temperature: 0.7,
                            topP: 0.8,
                            topK: 40,
                            maxOutputTokens: 2048,
                        }
                    })
                });
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`Quantum API Error ${response.status}: ${errorData.error?.message || 'Unknown neural disruption'}`);
                }
                const data = await response.json();
                if (!data.candidates || !data.candidates[0] || !data.candidates[0].content) {
                    throw new Error('Invalid quantum response format');
                }
                return data.candidates[0].content.parts[0].text;
            } catch (error) {
                console.error('üî¥ Quantum AI Error:', error);
                throw error;
            }
        }

        const addMessage = (htmlContent, isUser = false) => {
            const bubble = document.createElement('div');
            bubble.className = `w-full flex ${isUser ? 'justify-end' : 'justify-start'} animate-float`;
            const contentWrapper = document.createElement('div');
            contentWrapper.className = `p-4 rounded-xl max-w-[90%] ${isUser ? 'chat-bubble-user' : 'chat-bubble-ai'} neon-glow transition-all duration-300 hover:scale-105`;
            
            const header = document.createElement('div');
            header.className = 'flex items-center mb-2 text-xs font-mono text-gray-400';
            header.innerHTML = `<span>${isUser ? 'üë§ NEURAL USER' : 'ü§ñ QUANTUM AI'}</span><span class="mx-2">|</span><span>${new Date().toLocaleTimeString()}</span>`;

            const content = document.createElement('div');
            content.innerHTML = htmlContent;

            contentWrapper.appendChild(header);
            contentWrapper.appendChild(content);
            bubble.appendChild(contentWrapper);
            chatWindow.appendChild(bubble);
            chatWindow.scrollTop = chatWindow.scrollHeight;
            
            return contentWrapper; // Return reference for updates
        };

        const sendMessage = async () => {
            if (isProcessing) return;
            const prompt = promptInput.value.trim();
            if (!prompt) return;

            if (!gapi.client.getToken() || !DRIVE_FOLDER_ID) {
                addMessage('<p class="text-red-400">‚ùå Quantum authentication required. Please sync with Google Matrix first.</p>');
                return;
            }

            isProcessing = true;
            sendButton.disabled = true;
            sendButton.innerHTML = '‚ö°PROCESSING...';

            addMessage(`<p>${escapeHtml(prompt)}</p>`, true);
            promptInput.value = '';

            const loadingMessage = addMessage('<p>üß† Quantum neural networks processing...</p>');

            try {
                let contextMessage = prompt;
                if (conversationHistory.length > 0) {
                    const recentHistory = conversationHistory.slice(-6);
                    const contextParts = recentHistory.map(item => `${item.role.toUpperCase()}: ${item.content}`).join('\n');
                    contextMessage = `NEURAL CONTEXT:\n${contextParts}\n\nCURRENT TRANSMISSION: ${prompt}\n\nNote: You are an advanced AI assistant in the "Operation Offload" quantum workspace. Respond with technical precision and futuristic terminology when appropriate.`;
                }

                const aiResponse = await callGeminiAPI(contextMessage);

                conversationHistory.push({ role: 'user', content: prompt, timestamp: new Date().toISOString(), quantumId: generateQuantumSignature() });
                conversationHistory.push({ role: 'assistant', content: aiResponse, timestamp: new Date().toISOString(), quantumId: generateQuantumSignature() });

                // Update the loading message with the actual response
                const contentDiv = loadingMessage.querySelector('p');
                if(contentDiv) {
                    contentDiv.parentElement.innerHTML = formatAIResponse(aiResponse);
                } else {
                    loadingMessage.innerHTML = formatAIResponse(aiResponse);
                }
                
                await saveEnhancedConversationToDrive();

                const successIndicator = document.createElement('div');
                successIndicator.className = 'text-neon-green text-xs mt-2 flex items-center font-mono';
                successIndicator.innerHTML = '‚ö°&nbsp;Quantum archived to neural matrix';
                loadingMessage.appendChild(successIndicator);

                if (conversationHistory.length > 0 && conversationHistory.length % 6 === 0) {
                    suggestSmartExtraction();
                }

            } catch (error) {
                console.error('üî¥ Neural processing error:', error);
                loadingMessage.innerHTML = `<p class="text-red-400">‚ùå Quantum disruption detected: ${escapeHtml(error.message)}</p>`;
            } finally {
                isProcessing = false;
                sendButton.disabled = false;
                sendButton.innerHTML = '‚ö°TRANSMIT';
            }
        };

        async function saveEnhancedConversationToDrive() {
            try {
                const timestamp = generateTimestamp();
                const filename = `${extractionSettings.filePrefix}neural_session_${timestamp}.json`;
                
                let conversationData = {
                    sessionType: 'neural-conversation',
                    timestamp: new Date().toISOString(),
                    quantumSignature: generateQuantumSignature(),
                    conversationHistory: conversationHistory,
                    metadata: {
                        totalExchanges: Math.floor(conversationHistory.length / 2),
                        sessionDurationMinutes: calculateSessionDuration(),
                        neuralComplexity: calculateNeuralComplexity(),
                        exportedBy: 'Operation Offload Quantum Engine',
                        version: '2.0'
                    },
                    settings: extractionSettings,
                    analysis: analyzeConversationContent()
                };

                await saveToGoogleDrive(JSON.stringify(conversationData, null, 2), filename);
                console.log('üîµ Neural session archived to quantum matrix');
            } catch (error) {
                console.error('üî¥ Neural archival failed:', error);
            }
        }
        
        function analyzeConversationContent() {
            const analysis = {
                detectedContentTypes: [],
                potentialExtractions: [],
                topicComplexity: 'standard',
                suggestedCategories: []
            };
            const fullText = conversationHistory.map(h => h.content).join(' ').toLowerCase();

            Object.entries(contentTypes).forEach(([type, config]) => {
                const matches = config.patterns.filter(pattern => fullText.includes(pattern));
                if (matches.length > 0) {
                    analysis.detectedContentTypes.push({
                        type: type,
                        confidence: matches.length / config.patterns.length,
                        matches: matches
                    });
                }
            });

            analysis.detectedContentTypes.forEach(detected => {
                if (detected.confidence > 0.3) {
                    analysis.potentialExtractions.push({
                        type: detected.type,
                        priority: detected.confidence > 0.6 ? 'high' : 'medium',
                        reason: `Detected ${detected.matches.length} relevant patterns`
                    });
                }
            });
            return analysis;
        }

        function calculateSessionDuration() {
            if (conversationHistory.length < 2) return 0;
            const start = new Date(conversationHistory[0].timestamp);
            const end = new Date(conversationHistory[conversationHistory.length - 1].timestamp);
            return Math.round((end - start) / 1000 / 60); // minutes
        }

        function calculateNeuralComplexity() {
            const totalWords = conversationHistory.reduce((sum, h) => sum + h.content.split(' ').length, 0);
            const avgWordsPerMessage = totalWords / Math.max(conversationHistory.length, 1);
            if (avgWordsPerMessage > 100) return 'high';
            if (avgWordsPerMessage > 50) return 'medium';
            return 'standard';
        }

        function suggestSmartExtraction() {
            const analysis = analyzeConversationContent();
            if (analysis.potentialExtractions.length > 0) {
                const suggestion = document.createElement('div');
                suggestion.className = 'w-full flex justify-center mt-4 animate-float';
                suggestion.innerHTML = `
                    <div class="bg-indigo-900/50 border border-indigo-500 rounded-lg p-3 text-center text-sm">
                        <p class="font-bold text-indigo-300">üß† QUANTUM SUGGESTION</p>
                        <p>Neural patterns detected: <span class="font-semibold">${analysis.potentialExtractions.map(p => p.type).join(', ')}</span></p>
                        <button class="mt-2 bg-indigo-600 hover:bg-indigo-700 text-white py-1 px-3 rounded-md text-xs">üéØ SMART EXTRACT</button>
                    </div>
                `;
                chatWindow.appendChild(suggestion);
                chatWindow.scrollTop = chatWindow.scrollHeight;
            }
        }

        // --- ARCHIVE & DOWNLOAD FUNCTIONS ---
        function enableArchiveFeatures() {
            document.getElementById('download-current-chat').disabled = false;
            document.getElementById('download-all-drive-content').disabled = false;
            document.getElementById('bulk-download-interactions').disabled = false;
            document.getElementById('generate-summary-report').disabled = false;
        }

        function disableArchiveFeatures() {
            document.getElementById('download-current-chat').disabled = true;
            document.getElementById('download-all-drive-content').disabled = true;
            document.getElementById('bulk-download-interactions').disabled = true;
            document.getElementById('generate-summary-report').disabled = true;
        }

        async function downloadCurrentChat() {
            if (conversationHistory.length === 0) {
                alert('No conversation to download!');
                return;
            }
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const filename = `current-chat-${timestamp}.json`;
            const chatData = {
                exportType: 'current-chat',
                timestamp: new Date().toISOString(),
                conversationHistory: conversationHistory,
                metadata: {
                    totalMessages: conversationHistory.length,
                    exportedBy: 'Operation Offload',
                    version: '2.0'
                }
            };
            downloadJSON(chatData, filename);
            updateDownloadStatus(`Current chat exported as ${filename}`);
        }

        async function downloadAllDriveContent() {
            if (!DRIVE_FOLDER_ID) { alert('Drive folder not initialized!'); return; }
            showProgress(true);
            updateProgress(0, 'Scanning Google Drive folder...');
            try {
                const files = await getAllDriveFiles();
                updateProgress(30, `Found ${files.length} files. Downloading content...`);
                const allContent = [];
                for (let i = 0; i < files.length; i++) {
                    const file = files[i];
                    updateProgress(30 + (50 * (i + 1)) / files.length, `Downloading: ${file.name}`);
                    try {
                        const content = await downloadDriveFile(file.id);
                        allContent.push({
                            filename: file.name,
                            createdTime: file.createdTime,
                            modifiedTime: file.modifiedTime,
                            size: file.size,
                            content: content
                        });
                    } catch (error) {
                        console.warn(`Failed to download ${file.name}:`, error);
                        allContent.push({
                            filename: file.name,
                            createdTime: file.createdTime,
                            error: error.message
                        });
                    }
                }
                updateProgress(90, 'Preparing download package...');
                const archiveData = {
                    exportType: 'drive-archive',
                    timestamp: new Date().toISOString(),
                    folderName: 'Gemini_Synapse_Offload',
                    totalFiles: files.length,
                    files: allContent,
                };
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                const filename = `drive-archive-${timestamp}.json`;
                downloadJSON(archiveData, filename);
                updateProgress(100, `Complete! Downloaded ${files.length} files.`);
                updateDownloadStatus(`Drive archive exported as ${filename}`);
            } catch (error) {
                console.error('Error downloading drive content:', error);
                updateDownloadStatus(`Error: ${error.message}`, 'text-red-400');
            } finally {
                setTimeout(() => showProgress(false), 2000);
            }
        }

        async function bulkDownloadInteractions() {
            if (!DRIVE_FOLDER_ID) { alert('Drive folder not initialized!'); return; }
            showProgress(true);
            updateProgress(0, 'Gathering all interaction data...');
            try {
                const files = await getAllDriveFiles();
                const conversationFiles = files.filter(file => file.name.includes('neural_session') || file.name.endsWith('.json'));
                updateProgress(20, `Found ${conversationFiles.length} conversation files.`);
                const allInteractions = [];
                for (let i = 0; i < conversationFiles.length; i++) {
                    const file = conversationFiles[i];
                    updateProgress(20 + (60 * (i + 1)) / conversationFiles.length, `Processing: ${file.name}`);
                    try {
                        const content = await downloadDriveFile(file.id);
                        allInteractions.push(JSON.parse(content));
                    } catch (error) {
                        console.warn(`Failed to process ${file.name}:`, error);
                    }
                }
                updateProgress(90, 'Generating comprehensive export...');
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                const filename = `bulk-interactions-${timestamp}.json`;
                downloadJSON({ exportType: 'bulk-interactions', interactions: allInteractions }, filename);
                updateProgress(100, `Exported ${conversationFiles.length} interactions!`);
                updateDownloadStatus(`Bulk export completed: ${filename}`);
            } catch (error) {
                console.error('Error in bulk download:', error);
                updateDownloadStatus(`Error: ${error.message}`, 'text-red-400');
            } finally {
                setTimeout(() => showProgress(false), 2000);
            }
        }

        async function generateSummaryReport() {
            if (!DRIVE_FOLDER_ID) { alert('Drive folder not initialized!'); return; }
            showProgress(true);
            updateProgress(0, 'Analyzing all content...');
            try {
                const files = await getAllDriveFiles();
                updateProgress(20, `Analyzing ${files.length} files...`);
                const report = {
                    exportType: 'summary-report',
                    timestamp: new Date().toISOString(),
                    overview: {
                        totalFiles: files.length,
                        totalSize: files.reduce((sum, f) => sum + (parseInt(f.size) || 0), 0),
                        fileTypes: {}
                    },
                    recentActivity: files.slice(0, 10).map(f => ({ name: f.name, created: f.createdTime, size: f.size }))
                };
                 files.forEach(file => {
                    const extension = file.name.split('.').pop().toLowerCase();
                    report.overview.fileTypes[extension] = (report.overview.fileTypes[extension] || 0) + 1;
                });
                updateProgress(100, 'Report generated successfully!');
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                const filename = `summary-report-${timestamp}.json`;
                downloadJSON(report, filename);
                updateDownloadStatus(`Summary report generated: ${filename}`);
            } catch (error) {
                console.error('Error generating summary:', error);
                updateDownloadStatus(`Error: ${error.message}`, 'text-red-400');
            } finally {
                setTimeout(() => showProgress(false), 2000);
            }
        }

        // --- HELPER FUNCTIONS FOR DOWNLOADS & UTILS ---
        async function getAllDriveFiles() {
            try {
                const response = await gapi.client.drive.files.list({
                    q: `parents in '${DRIVE_FOLDER_ID}' and trashed=false`,
                    fields: 'files(id, name, createdTime, modifiedTime, size)',
                    orderBy: 'createdTime desc'
                });
                return response.result.files || [];
            } catch (error) {
                throw new Error(`Failed to list files: ${error.result.error.message}`);
            }
        }

        async function downloadDriveFile(fileId) {
            try {
                const response = await gapi.client.drive.files.get({
                    fileId: fileId,
                    alt: 'media'
                });
                return response.body;
            } catch (error) {
                throw new Error(`Failed to download file: ${error.result.error.message}`);
            }
        }

        function downloadJSON(data, filename) {
            const jsonString = JSON.stringify(data, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function showProgress(show) {
            document.getElementById('download-progress').classList.toggle('hidden', !show);
        }

        function updateProgress(percent, text) {
            document.getElementById('progress-bar').style.width = `${percent}%`;
            document.getElementById('progress-text').textContent = text;
        }

        function updateDownloadStatus(message, className = 'text-green-400') {
            const statusDiv = document.getElementById('download-status');
            statusDiv.textContent = message;
            statusDiv.className = `text-sm ${className}`;
        }
        
        function formatAIResponse(text) {
             // Basic formatting for AI responses
             return escapeHtml(text)
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/\*(.*?)\*/g, '<em>$1</em>')
                .replace(/`(.*?)`/g, '<code class="bg-gray-700 text-teal-300 px-1 rounded">$1</code>')
                .replace(/```([\s\S]*?)```/g, '<pre class="code-block bg-black p-2 rounded-md my-2"><code>$1</code></pre>')
                .replace(/\n/g, '<br>');
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function generateQuantumSignature() {
             return 'qs-' + Date.now().toString(36) + '-' + Math.random().toString(36).substr(2, 9);
        }

        function generateTimestamp() {
            return new Date().toISOString().replace(/[:.]/g, '-');
        }

        // --- GOOGLE DRIVE FUNCTIONS ---
        async function findOrCreateFolder(folderName) {
            const searchResponse = await gapi.client.drive.files.list({
                q: `name='${folderName}' and mimeType='application/vnd.google-apps.folder' and trashed=false`,
                fields: 'files(id, name)'
            });
            if (searchResponse.result.files && searchResponse.result.files.length > 0) {
                console.log(`Found existing folder: ${folderName}`);
                return searchResponse.result.files[0].id;
            }
            const createResponse = await gapi.client.drive.files.create({
                resource: { name: folderName, mimeType: 'application/vnd.google-apps.folder' },
                fields: 'id'
            });
            console.log(`Created new folder: ${folderName}`);
            return createResponse.result.id;
        }

        async function saveToGoogleDrive(content, filename) {
            if (!DRIVE_FOLDER_ID) throw new Error('Drive folder not initialized');
            const boundary = '-------314159265358979323846';
            const delimiter = `\r\n--${boundary}\r\n`;
            const close_delim = `\r\n--${boundary}--`;
            const metadata = { name: filename, parents: [DRIVE_FOLDER_ID] };
            const multipartRequestBody =
                delimiter + 'Content-Type: application/json\r\n\r\n' + JSON.stringify(metadata) +
                delimiter + 'Content-Type: application/json; charset=UTF-8\r\n\r\n' + content +
                close_delim;
            const request = await gapi.client.request({
                path: 'https://www.googleapis.com/upload/drive/v3/files',
                method: 'POST',
                params: { uploadType: 'multipart' },
                headers: { 'Content-Type': `multipart/related; boundary="${boundary}"` },
                body: multipartRequestBody
            });
            console.log('File saved to Drive:', request.result);
            return request.result;
        }

        // --- EVENT LISTENERS ---
        sendButton.addEventListener('click', sendMessage);
        promptInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });

        promptInput.addEventListener('input', function() {
            this.style.height = 'auto';
            this.style.height = (this.scrollHeight) + 'px';
        });

        document.getElementById('download-current-chat').addEventListener('click', downloadCurrentChat);
        document.getElementById('download-all-drive-content').addEventListener('click', downloadAllDriveContent);
        document.getElementById('bulk-download-interactions').addEventListener('click', bulkDownloadInteractions);
        document.getElementById('generate-summary-report').addEventListener('click', generateSummaryReport);

        console.log("Operation Offload initialized with full quantum archive capabilities!");
    </script>
</body>
</html>
